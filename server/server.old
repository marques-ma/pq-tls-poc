package main

import (
    // "crypto/tls"
    // "fmt"
    // "io"
    "log"
    // "net"
    "os/exec"
	"os"
)

func main() {
    // Define your OpenSSL command
    cmd := exec.Command(
        "openssl", "s_server",
        "-cert", "ecdsa_server.crt",       // ECDSA server certificate
        "-key", "ecdsa_key.pem",           // ECDSA server key
        "-cert2", "pq_server.crt",            // Post-quantum certificate
        "-key2", "pq_key.pem",              // Post-quantum key
        "-www",                              // Enable a simple web server
		"-tls1_3",
    )

    // Set command output to log
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr

    // Start the OpenSSL command
    if err := cmd.Start(); err != nil {
        log.Fatalf("Failed to start OpenSSL server: %v", err)
    }

    log.Println("OpenSSL server started. Listening for connections...")

    // Wait for the command to complete
    if err := cmd.Wait(); err != nil {
        log.Fatalf("OpenSSL server failed: %v", err)
    }
}

// func main() {
//     // Load the ECDSA server certificate and private key
//     cert, err := tls.LoadX509KeyPair("ecdsa_server.crt", "ecdsa_key.pem")
//     if err != nil {
//         log.Fatalf("Failed to load server certificate: %v", err)
//     }

//     // Create a TLS configuration
//     config := &tls.Config{
//         Certificates: []tls.Certificate{cert},
//         MinVersion:   tls.VersionTLS13,
//     }

//     // Start listening for incoming connections
//     listener, err := tls.Listen("tcp", ":4433", config)
//     if err != nil {
//         log.Fatalf("Failed to start server: %v", err)
//     }
//     defer listener.Close()

//     log.Println("Server listening on port 4433...")

//     for {
//         conn, err := listener.Accept()
//         if err != nil {
//             log.Printf("Failed to accept connection: %v", err)
//             continue
//         }

//         go handleConnection(conn)
//     }
// }

// func handleConnection(conn net.Conn) {
//     defer conn.Close()
//     log.Println("Client connected.")

//     // Start the PQ handshake via OpenSSL
//     cmd := exec.Command("openssl", "s_server", "-cert", "pq_server.crt", "-key", "pq_key.pem", "-www", "-msg")
//     cmd.Stdin = conn // Use the connection as stdin for OpenSSL

//     // Run OpenSSL command
//     if err := cmd.Start(); err != nil {
//         log.Printf("Failed to start OpenSSL server: %v", err)
//         return
//     }

//     // Read messages from the client
//     buffer := make([]byte, 1024)
//     n, err := conn.Read(buffer)
//     if err != nil && err != io.EOF {
//         log.Printf("Failed to read from client: %v", err)
//         return
//     }

//     message := string(buffer[:n])
//     log.Printf("Received message from client: %s", message)

//     // Send an acknowledgment after PQ handshake
//     _, err = conn.Write([]byte("Acknowledgment: PQ handshake completed.\n"))
//     if err != nil {
//         log.Printf("Failed to send acknowledgment: %v", err)
//     }

//     log.Println("Connection closed.")
// }
